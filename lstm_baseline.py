# -*- coding: utf-8 -*-
"""RDF_linearized.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/NiloyPurkait/GSoC-2020/blob/master/V1.0/RNN/RDF_linearized.ipynb

# Linearized RDF to text with a neural machine translation approach
"""


####
##
##
## | Implement plot attention?
##
##
###

import tensorflow as tf

import matplotlib.pyplot as plt
import matplotlib.ticker as ticker
from sklearn.model_selection import train_test_split
import random
import unicodedata
import re
import numpy as np
import os
import io
import time
from re import finditer
import argparse


"""## Preprocessing helper functions"""

# Converts the unicode file to ascii
def unicode_to_ascii(s):
  return ''.join(c for c in unicodedata.normalize('NFD', s)
      if unicodedata.category(c) != 'Mn')

# split lowercase followed by uppercase letter into words  
def camel_case_split(identifier):
    matches = finditer('.+?(?:(?<=[a-z])(?=[A-Z])|(?<=[A-Z])(?=[A-Z][a-z])|$)', identifier)
    return ' '.join([m.group(0) for m in matches])


def preprocess_sentence(w):
  w = unicode_to_ascii(w.lower().strip())
  
  # creating a space between a word and the punctuation following it
  w = re.sub(r"([?.!,多])", r" \1 ", w)
  w = re.sub(r'[" "]+', " ", w)
  
  # replacing everything with space except (a-z, A-Z, "0-9", ".", "?", "!", ",")
  w = re.sub(r"[^a-zA-Z0-9?.!,多']+", " ", w)
  w = w.strip()
  
  # adding a start and an end token to the sentence
  w = '<start> ' + w + ' <end>'
  return w


def preprocess_rdf(w):

  w = unicode_to_ascii(w.strip())
  w = camel_case_split(w)

  # creating a space between a word and the punctuation following it
  w = re.sub(r"([?.!,多])", r" \1 ", w)
  w = re.sub(r'[" "]+', " ", w)

  # replacing everything with space except (a-z, A-Z, 0-9, ".", "?", "!", "," , "/", "\" )
  w = re.sub(r"[^a-zA-Z0-9?.!,多<>\\\\////']+", " ", w)
  w = w.strip()

  # adding a start and an end token to the sentence
  w = '<start> ' + w.lower() + ' <end>'
  return w


"""## Dataset creation and loading functions"""
def create_dataset(path):
  lines = io.open(path, encoding='UTF-8').read().strip().split('\n')

  word_pairs = []
  for l in lines:
    rdf, text = l.split('\t')
    word_pairs.append([preprocess_sentence(text), preprocess_rdf(rdf)])

  return zip(*word_pairs)



def tokenize(lang, char=False):

  if char:
      lang_tokenizer = tf.keras.preprocessing.text.Tokenizer(
           filters='',char_level=True)
  else:
      lang_tokenizer = tf.keras.preprocessing.text.Tokenizer(
           filters='', oov_token = '<UNK>')
  lang_tokenizer.fit_on_texts(lang)

  tensor = lang_tokenizer.texts_to_sequences(lang)

  tensor = tf.keras.preprocessing.sequence.pad_sequences(tensor,
                                                         padding='post')
  return tensor, lang_tokenizer

def load_dataset(path, num_examples=None, char=False):
  # creating cleaned input, output pairs
  targ_lang, inp_lang  = create_dataset(path)

  input_tensor, inp_lang_tokenizer = tokenize(inp_lang)
  target_tensor, targ_lang_tokenizer = tokenize(targ_lang, char)

  return input_tensor, target_tensor, inp_lang_tokenizer, targ_lang_tokenizer



def convert(lang, tensor):
  for t in tensor:
    if t!=0:
      print ("%d ----> %s" % (t, lang.index_word[t]))



"""## Define Encoder architecture

  Each input words is assigned a weight by the attention mechanism which is then used
  by the decoder to predict the next word in the sentence. The input is put through an
  encoder model which gives us the encoder output of shape *(batch_size, max_length, hidden_size)*
  and the encoder hidden state of shape *(batch_size, hidden_size)*.

"""

class Encoder(tf.keras.Model):
  def __init__(self, vocab_size, embedding_dim, enc_units, batch_sz):
    super(Encoder, self).__init__()
    self.batch_sz = batch_sz
    self.enc_units = enc_units
    self.embedding = tf.keras.layers.Embedding(vocab_size, embedding_dim)
    self.lstm = tf.keras.layers.LSTM(self.enc_units,
                                   return_sequences=True,
                                   return_state=True,
                                   recurrent_initializer='glorot_uniform')

  def call(self, x, hidden, carry):
    x = self.embedding(x)
    output, state, c = self.lstm(x, initial_state = [hidden, carry])###################
    return output, state, c

  def initialize_hidden_state(self):
    return tf.zeros((self.batch_sz, self.enc_units))

  def initialize_carry_state(self):
    return tf.zeros((self.batch_sz, self.enc_units))



"""## Define a custom Bahdanau attention layer"""

class BahdanauAttention(tf.keras.layers.Layer):
  def __init__(self, units):
    super(BahdanauAttention, self).__init__()
    self.W1 = tf.keras.layers.Dense(units)
    self.W2 = tf.keras.layers.Dense(units)
    self.V = tf.keras.layers.Dense(1)

  def call(self, query, values):
    # query hidden state shape == (batch_size, hidden size)
    # query_with_time_axis shape == (batch_size, 1, hidden size)
    # values shape == (batch_size, max_len, hidden size)
    # we are doing this to broadcast addition along the time axis to calculate the score
    query_with_time_axis = tf.expand_dims(query, 1)

    # score shape == (batch_size, max_length, 1)
    # we get 1 at the last axis because we are applying score to self.V
    # the shape of the tensor before applying self.V is (batch_size, max_length, units)
    score = self.V(tf.nn.tanh(
        self.W1(query_with_time_axis) + self.W2(values)))

    # attention_weights shape == (batch_size, max_length, 1)
    attention_weights = tf.nn.softmax(score, axis=1)

    # context_vector shape after sum == (batch_size, hidden_size)
    context_vector = attention_weights * values
    context_vector = tf.reduce_sum(context_vector, axis=1)

    return context_vector, attention_weights


"""## Define Decoder architecture"""

class Decoder(tf.keras.Model):
  def __init__(self, vocab_size, embedding_dim, dec_units, batch_sz):
    super(Decoder, self).__init__()
    self.batch_sz = batch_sz
    self.dec_units = dec_units
    self.embedding = tf.keras.layers.Embedding(vocab_size, embedding_dim)
    self.lstm = tf.keras.layers.LSTM(self.dec_units,
                                   return_sequences=True,
                                   return_state=True,
                                   recurrent_initializer='glorot_uniform')
    
    self.fc = tf.keras.layers.Dense(vocab_size)

    # used for attention
    self.attention = BahdanauAttention(self.dec_units)

  def call(self, x, hidden, carry, enc_output):
    # enc_output shape == (batch_size, max_length, hidden_size)
    context_vector, attention_weights = self.attention(hidden, enc_output)

    # x shape after passing through embedding == (batch_size, 1, embedding_dim)
    x = self.embedding(x)

    # x shape after concatenation == (batch_size, 1, embedding_dim + hidden_size)
    x = tf.concat([tf.expand_dims(context_vector, 1), x], axis=-1)

    # passing the concatenated vector to the LSTM
    output, state, carry = self.lstm(x)

    # output shape == (batch_size * 1, hidden_size)
    output = tf.reshape(output, (-1, output.shape[2]))

    # output shape == (batch_size, vocab)
    x = self.fc(output)

    return x, state, carry, attention_weights

  def initialize_carry_state(self):
    return tf.zeros((self.batch_sz, self.dec_units))

def loss_function(real, pred):
  mask = tf.math.logical_not(tf.math.equal(real, 0))
  loss_ = loss_object(real, pred)

  mask = tf.cast(mask, dtype=loss_.dtype)
  loss_ *= mask

  return tf.reduce_mean(loss_)


"""## Training

1. Pass the *input* through the *encoder* which return *encoder output* and the *encoder hidden state*.
2. The encoder output, encoder hidden state and the decoder input (which is the *start token*) is passed to the decoder.
3. The decoder returns the *predictions* and the *decoder hidden state*.
4. The decoder hidden state is then passed back into the model and the predictions are used to calculate the loss.
5. Use *teacher forcing* to decide the next input to the decoder.
6. *Teacher forcing* is the technique where the *target word* is passed as the *next input* to the decoder.
7. The final step is to calculate the gradients and apply it to the optimizer and backpropagate.
"""


def plot_training_loss(loss):
  # summarize history for loss
  plt.plot(loss)
  plt.title('model loss')
  plt.ylabel('loss')
  plt.xlabel('epoch')
  plt.show()

def save_checkpoint():
  encoder.save_weights(args.checkpoint_path + '/full_encoder')
  decoder.save_weights(args.checkpoint_path + '/full_decoder')

def restore_checkpoint():
  try:
    encoder.load_weights(args.checkpoint_path + '/full_encoder')
    decoder.load_weights(args.checkpoint_path + '/full_decoder')
    print('Model weights loaded.')
  except Exception as e:
    print(e, ' occured while loading weights.')
    pass

"""## Translate

* The evaluate function is similar to the training loop, except we don't
  use *teacher forcing* here. The input to the decoder at each time step is its
  previous predictions along with the hidden state and the encoder output.
* Stop predicting when the model predicts the *end token*.
* And store the *attention weights for every time step*.

Note: The encoder output is calculated only once for one input.
"""

def evaluate(sentence):

  sentence = preprocess_sentence(sentence)

  inputs = [inp_lang.word_index[i] if i in list(inp_lang.word_index.keys()) else inp_lang.word_index['<UNK>'] for i in sentence.split(' ')]
  inputs = tf.keras.preprocessing.sequence.pad_sequences([inputs],
                                                         maxlen=max_length_inp,
                                                         padding='post')
  inputs = tf.convert_to_tensor(inputs)
  result = ''

  # Encoder inputs
  enc_hidden = tf.zeros((1, units))
  enc_carry = tf.zeros((1, units))
  enc_out, enc_hidden, enc_carry = encoder(inputs, enc_hidden, enc_carry)

  dec_hidden = enc_hidden
  dec_input = tf.expand_dims([targ_lang.word_index['<start>']], 0)
  dec_carry = [tf.zeros((1, units))]

  #without teacher forcing
  for t in range(max_length_targ):
    predictions, dec_hidden, dec_carry, attention_weights = decoder(dec_input,
                                                         dec_hidden, dec_carry,
                                                         enc_out)
    predicted_id = tf.argmax(predictions[0]).numpy()
    result += targ_lang.index_word[predicted_id] + ' '

    if targ_lang.index_word[predicted_id] == '<end>':
      return result, sentence
    # the predicted ID is fed back into the model
    dec_input = tf.expand_dims([predicted_id], 0)
  return result, sentence

def translate(sentence):
  result, sentence = evaluate(sentence)
  print('Input: %s' % (sentence))
  print('Predicted translation: {}'.format(result))


def train_model():
  
  @tf.function
  def train_step(inp, targ, enc_hidden, enc_carry):

    loss = 0
    with tf.GradientTape() as tape:

      enc_output, enc_hidden, enc_carry = encoder(inp, enc_hidden, enc_carry)
      dec_hidden = enc_hidden
      dec_carry = decoder.initialize_carry_state()
      dec_input = tf.expand_dims([targ_lang.word_index['<start>']] * BATCH_SIZE, 1)

      # Teacher forcing - feeding the target as the next input
      for t in range(1, targ.shape[1]):
        
        # passing enc_output to the decoder#dec_input, dec_hidden, enc_output
        predictions, dec_hidden, dec_carry, _ = decoder(dec_input, dec_hidden, dec_carry, enc_output)
        loss += loss_function(targ[:, t], predictions)
        # using teacher forcing
        dec_input = tf.expand_dims(targ[:, t], 1)

    batch_loss = (loss / int(targ.shape[1]))

    variables = encoder.trainable_variables + decoder.trainable_variables
    gradients = tape.gradient(loss, variables)
    optimizer.apply_gradients(zip(gradients, variables))
    return batch_loss

  EPOCHS = 10
  loss = []
  for epoch in range(EPOCHS):
    
    start = time.time()
    # Initialize encoder hidden and carry states
    enc_hidden = encoder.initialize_hidden_state()
    enc_carry = encoder.initialize_carry_state()
    dec_carry = decoder.initialize_carry_state()
    # Track total loss
    total_loss = 0

    # Calculate batch loss per training step
    for (batch, (inp, targ)) in enumerate(dataset.take(steps_per_epoch)):
      
      batch_loss = train_step(inp, targ, enc_hidden, enc_carry)
      total_loss += batch_loss

      if batch % 100 == 0:
        print('Epoch {} Batch {} Loss {:.4f}'.format(epoch + 1,
                                                     batch,
                                                     batch_loss.numpy()))
    # saving (checkpoint) the model every 2 epochs
    if (epoch + 1) % 2 == 0:
      save_checkpoint()

    loss.append(total_loss / steps_per_epoch)
    print('Epoch {} Loss {:.4f}'.format(epoch + 1, loss[-1]))
    print('Time taken for 1 epoch {} sec\n'.format(time.time() - start))

####
##
## | Main 
##
###

def get_args():

  parser = argparse.ArgumentParser(description="Main Arguments")

  parser.add_argument(
    '--file_path', default='./data/parsed_xml_data.txt', type=str, required=False,
    help='Path to training data')

  parser.add_argument(
    '--checkpoint_path', default='C:/Users/npurk/Desktop/testenv/checkpoints/lstm', type=str, required=False,
    help='Path to checkpoint files')

  parser.add_argument(
    '--BATCH_SIZE', default=32, type=int, required=False,
    help='Mini-batch size')

  parser.add_argument(
    '--embedding_dim', default=256, type=int, required=False,
    help='Embedding dimension')

  parser.add_argument(
    '--units', default=1024, type=int, required=False,
    help='Number of units in LSTM layer, for encoder and decoder')

  parser.add_argument(
    '--EPOCHS', default=10, type=int, required=False,
    help='Number of epochs model should train for')

  args = parser.parse_args()

  return args


if __name__ == '__main__':

  args = get_args()
  BATCH_SIZE = args.BATCH_SIZE
  embedding_dim = args.embedding_dim
  units = args.units

  txts, trips = create_dataset(args.file_path)

  """### Make Linearized Dataset"""
  print('- | Tensorizing dataset...')
  input_tensor, target_tensor, inp_lang, targ_lang = load_dataset(args.file_path)
  # Calculate max_length of the target tensors
  max_length_targ, max_length_inp = target_tensor.shape[1], input_tensor.shape[1]

  print('- | Generating tf dataset...')
  BUFFER_SIZE = len(input_tensor)
  
  steps_per_epoch = len(input_tensor)//BATCH_SIZE

  vocab_inp_size = len( inp_lang.word_index) + 1
  vocab_tar_size = len(targ_lang.word_index) + 1
  print(vocab_inp_size)
  print(vocab_tar_size)
  

  dataset = tf.data.Dataset.from_tensor_slices((input_tensor, target_tensor)).shuffle(BUFFER_SIZE)
  dataset = dataset.batch(BATCH_SIZE, drop_remainder=True)

  encoder = Encoder(vocab_inp_size, embedding_dim, units, BATCH_SIZE)
  decoder = Decoder(vocab_tar_size, embedding_dim, units, BATCH_SIZE)

  """## Define the optimizer and the loss function"""
  optimizer = tf.keras.optimizers.Adam()
  loss_object = tf.keras.losses.SparseCategoricalCrossentropy(
      from_logits=True, reduction='none')

  print('- | Initiating training session...')

  restore_checkpoint()

  train_model()

  print('- | Translating input')
  i = trips[random.randint(0, 1000)]
  translate(i)


